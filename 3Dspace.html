<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Void: 3D Space Shooter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* Deep dark gradient matches fog */
            background: linear-gradient(to bottom, #000000 0%, #050010 100%);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 20;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }

        .score-container {
            color: #00ffff;
            font-size: 24px;
        }

        .health-bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid #ff0055;
            border-radius: 4px;
            overflow: hidden;
            background: rgba(50, 0, 20, 0.5);
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #ff0055;
            box-shadow: 0 0 15px #ff0055;
            transition: width 0.2s ease-out;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            z-index: 30;
        }

        h1 {
            color: #fff;
            font-size: 60px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            text-align: center;
        }

        p {
            color: #ccc;
            font-size: 18px;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.6;
            max-width: 600px;
        }

        .btn {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        .btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        .hidden {
            display: none !important;
        }

        .controls-hint {
            margin-top: 30px;
            font-size: 14px;
            color: #888;
        }
        
        .mobile-controls {
            display: none;
        }

        @media (max-width: 768px) {
            h1 { font-size: 40px; }
            .health-bar-container { width: 120px; }
            .mobile-controls {
                display: block;
                position: absolute;
                bottom: 20px;
                width: 100%;
                text-align: center;
                color: rgba(255,255,255,0.3);
                font-size: 12px;
                pointer-events: none;
            }
        }
    </style>
    <!-- Three.js CDN & Post-Processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-container">SCORE: <span id="score">0</span></div>
            <div class="health-bar-container">
                <div id="health-fill"></div>
            </div>
        </div>
        <div class="mobile-controls">Tap & Drag to Move ‚Ä¢ Tap to Shoot</div>
    </div>

    <div id="start-screen">
        <h1>Neon Void 3D</h1>
        <p>Pilot your ship through the asteroid belt. Destroy the alien invaders.<br>Survive as long as you can.</p>
        <button class="btn" id="start-btn">Initialize System</button>
        <div class="controls-hint">
            [WASD / ARROW KEYS] to Move &nbsp;&bull;&nbsp; [SPACE / CLICK] to Fire<br>
            Mobile: Touch Drag & Tap
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #ff0055; text-shadow: 0 0 20px #ff0055;">Critical Failure</h1>
        <p>Final Score: <span id="final-score" style="color: #fff; font-weight: bold;">0</span></p>
        <button class="btn" id="restart-btn">Reboot System</button>
    </div>

    <div id="game-container"></div>

<script>
/**
 * AUDIO SYNTHESIS ENGINE
 */
const AudioSynth = (function() {
    let ctx = null;
    let masterGain = null;

    function init() {
        if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = ctx.createGain();
            masterGain.gain.value = 0.3; 
            masterGain.connect(ctx.destination);
        }
        if (ctx.state === 'suspended') {
            ctx.resume();
        }
    }

    function playTone(freq, type, duration, vol = 1) {
        if (!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    }

    function playNoise(duration, vol = 1) {
        if (!ctx) return;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(masterGain);
        noise.start();
    }

    return {
        init,
        laser: () => {
            if(!ctx) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.frequency.setValueAtTime(800, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.15);
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
        },
        explosion: () => playNoise(0.4, 0.8),
        hit: () => playTone(150, 'square', 0.1, 0.5),
        powerup: () => {
            if(!ctx) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.frequency.setValueAtTime(300, ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(1000, ctx.currentTime + 0.3);
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.4, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
        },
        beam: () => { if(!ctx) return; playTone(80, 'sawtooth', 0.1, 0.1); }
    };
})();

/**
 * 3D GAME ENGINE (THREE.JS)
 */
const container = document.getElementById('game-container');
const uiScore = document.getElementById('score');
const uiHealth = document.getElementById('health-fill');
const finalScore = document.getElementById('final-score');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');

// Game State
let width, height;
let score = 0;
let gameRunning = false;
let screenShake = 0;
let lastTime = 0;

// Three.js Globals
let scene, camera, renderer, composer;
let lightAmbient, lightDir;

// Inputs
const keys = {};
const mouse = { x: 0, y: 0, down: false, touch: false };

// Logic & Entities
let player;
let bullets = [];
let particles = [];
let enemies = [];
let asteroids = [];
let powerups = [];
let starSystem;

// Config
const CONFIG = {
    playerSpeed: 450,
    fireRate: 0.15,
    asteroidSpawnRate: 1.5,
    enemySpawnRate: 2.5
};

// Math Helpers
const rnd = (min, max) => Math.random() * (max - min) + min;
const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

// --- Texture Generators for Clarity ---

// 1. Particle Texture
function createParticleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.3, 'rgba(255,255,255,0.5)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    return new THREE.CanvasTexture(canvas);
}
const particleTexture = createParticleTexture();

// 2. PowerUp Icon Generators (High Contrast)
function createIconTexture(icon, colorStr) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,128,128);
    
    // Solid, bright background
    const grad = ctx.createRadialGradient(64, 64, 10, 64, 64, 60);
    grad.addColorStop(0, colorStr);
    grad.addColorStop(0.8, colorStr); 
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,128,128);

    ctx.beginPath();
    ctx.arc(64, 64, 50, 0, Math.PI*2);
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#ffffff';
    ctx.stroke();

    ctx.font = '900 60px "Arial", sans-serif'; 
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(icon, 64, 68);

    const tex = new THREE.CanvasTexture(canvas);
    tex.needsUpdate = true;
    return tex;
}

const texHeart = createIconTexture('‚úö', 'rgba(255, 0, 85, 0.9)');   
const texShield = createIconTexture('üõ°Ô∏è', 'rgba(0, 255, 255, 0.9)'); 
const texClone = createIconTexture('üë•', 'rgba(0, 255, 0, 0.9)');   
const texBeam = createIconTexture('‚ö°', 'rgba(255, 170, 0, 0.9)'); 


// --- 3D SETUP ---
function initThree() {
    width = window.innerWidth;
    height = window.innerHeight;

    scene = new THREE.Scene();
    
    // FOG: Pushed further back to allow long-distance viewing
    // Objects will start appearing from deep black at 5000 units away
    const fogColor = 0x050010; 
    scene.fog = new THREE.Fog(fogColor, 1500, 5000); 

    const fov = 60;
    camera = new THREE.PerspectiveCamera(fov, width / height, 1, 6000);
    
    // Camera Position
    const camY = -height * 0.5 - 300; 
    const camZ = 350; 
    camera.position.set(0, camY, camZ);
    camera.lookAt(0, 200, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 2.0; // High exposure for brightness
    container.appendChild(renderer.domElement);

    // --- POST PROCESSING ---
    const renderScene = new THREE.RenderPass(scene, camera);
    
    // REDUCED BLOOM: Strength 0.5 ensures it's not blurry/over-glowing
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width, height), 0.5, 0.4, 0.2);
    
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // LIGHTING: High Intensity for visibility without glow
    lightAmbient = new THREE.AmbientLight(0xffffff, 3.5); 
    scene.add(lightAmbient);

    lightDir = new THREE.DirectionalLight(0xffffff, 4.0); 
    lightDir.position.set(50, -200, 200); 
    scene.add(lightDir);
    
    const lightBack = new THREE.DirectionalLight(0x0055ff, 2.0);
    lightBack.position.set(0, 500, -100);
    scene.add(lightBack);

    createStarfield();

    window.addEventListener('resize', onResize);
}

function onResize() {
    width = window.innerWidth;
    height = window.innerHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
    composer.setSize(width, height);
}

function createStarfield() {
    const geometry = new THREE.BufferGeometry();
    const count = 4000;
    const positions = new Float32Array(count * 3);
    for(let i=0; i<count; i++) {
        positions[i*3] = rnd(-2000, 2000);     
        positions[i*3+1] = rnd(-1000, 4000);   
        positions[i*3+2] = rnd(-500, 500);     
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({ 
        color: 0xffffff, 
        size: 3.0,
        transparent: true,
        opacity: 0.9,
        fog: true 
    });
    
    starSystem = new THREE.Points(geometry, material);
    scene.add(starSystem);
}

function updateStarfield(dt) {
    if(!starSystem) return;
    const positions = starSystem.geometry.attributes.position.array;
    const speed = 900; 
    
    for(let i=1; i<positions.length; i+=3) {
        positions[i] -= speed * dt;
        if(positions[i] < -height/2 - 400) {
            positions[i] = 4000; 
        }
    }
    starSystem.geometry.attributes.position.needsUpdate = true;
}

function mapTo3D(x, y) {
    return {
        x: x - width / 2,
        y: -(y - height / 2)
    };
}

// Materials - High emissive for "Neon" look, but controlled by post-processing
const matPlayer = new THREE.MeshStandardMaterial({ color: 0x00ffaa, emissive: 0x00ffaa, emissiveIntensity: 1.5, roughness: 0.2, metalness: 0.8 });
const matEnemyBody = new THREE.MeshStandardMaterial({ color: 0x551133, roughness: 0.3 });
const matEnemyWing = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0xff0055, emissiveIntensity: 1.5, roughness: 0.3 });
const matAsteroid = new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: true, roughness: 0.7, metalness: 0.2 }); 
const matBulletPlayer = new THREE.MeshBasicMaterial({ color: 0x00ffff });
const matBulletEnemy = new THREE.MeshBasicMaterial({ color: 0xff5500 });

// Particle material
const matParticleBase = new THREE.SpriteMaterial({
    map: particleTexture,
    color: 0xffffff,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});

class Entity3D {
    constructor() {
        this.mesh = new THREE.Group();
        scene.add(this.mesh);
    }
    destroy() {
        scene.remove(this.mesh);
    }
    sync(x, y, rot = 0) {
        const pos = mapTo3D(x, y);
        this.mesh.position.set(pos.x, pos.y, 0);
        this.mesh.rotation.z = rot;
    }
}

class Particle extends Entity3D {
    constructor(x, y, color, speed, life) {
        super();
        this.x = x; this.y = y;
        this.life = life; this.maxLife = life;
        
        this.mat = matParticleBase.clone();
        this.mat.color.set(color);
        this.mesh = new THREE.Sprite(this.mat);
        this.mesh.scale.set(30, 30, 1);
        scene.add(this.mesh);
        
        const angle = rnd(0, Math.PI*2);
        const vel = rnd(20, speed);
        this.vx = Math.cos(angle) * vel;
        this.vy = Math.sin(angle) * vel;
        this.vz = rnd(-80, 80); 
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.mesh.position.z += this.vz * dt;
        this.life -= dt;
        
        const lifeRatio = this.life / this.maxLife;
        this.mat.opacity = lifeRatio;
        const scale = 30 * lifeRatio;
        this.mesh.scale.set(scale, scale, 1);

        const pos = mapTo3D(this.x, this.y);
        this.mesh.position.x = pos.x;
        this.mesh.position.y = pos.y;
    }
}

class Bullet extends Entity3D {
    constructor(x, y, angle, isEnemy = false) {
        super();
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (isEnemy ? 400 : 800);
        this.vy = Math.sin(angle) * (isEnemy ? 400 : 800);
        this.life = 1.5;
        this.isEnemy = isEnemy;
        this.color = isEnemy ? '#ff5500' : '#00ffff';

        const geo = new THREE.CylinderGeometry(3, 3, 40, 8); 
        geo.rotateZ(Math.PI / 2); 
        const mat = isEnemy ? matBulletEnemy : matBulletPlayer;
        this.mesh = new THREE.Mesh(geo, mat);
        scene.add(this.mesh);
        this.mesh.rotation.z = angle;
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        this.sync(this.x, this.y, this.mesh.rotation.z);
    }
}

class Asteroid extends Entity3D {
    constructor() {
        super();
        this.radius = rnd(30, 70); 
        // Spawn far "above" screen in Logic coordinates
        this.x = rnd(0, width);
        this.y = -2000; // Deep in distance
        
        this.vx = rnd(-20, 20); 
        this.vy = rnd(300, 500); 
        
        this.rotX = rnd(0.5, 2);
        this.rotY = rnd(0.5, 2);
        this.hp = Math.ceil(this.radius / 10);
        
        const geo = new THREE.DodecahedronGeometry(this.radius, 1); 
        this.mesh = new THREE.Mesh(geo, matAsteroid);
        scene.add(this.mesh);
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt; // Move "Down" towards player
        this.mesh.rotation.x += this.rotX * dt;
        this.mesh.rotation.y += this.rotY * dt;
        this.sync(this.x, this.y);
    }
}

class Enemy extends Entity3D {
    constructor() {
        super();
        this.x = rnd(50, width - 50);
        this.y = -2000; // Deep spawn
        
        this.radius = 25;
        this.vx = rnd(-50, 50);
        this.vy = rnd(250, 450); 
        
        this.color = '#ff0055';
        this.hp = 3;
        this.timer = 0;
        this.moveType = Math.random() > 0.5 ? 'sine' : 'chase';
        this.fireTimer = rnd(1, 2.5);

        const bodyGeo = new THREE.SphereGeometry(12, 16, 16);
        const body = new THREE.Mesh(bodyGeo, matEnemyBody);
        this.mesh.add(body);

        const wingGeo = new THREE.BoxGeometry(10, 40, 40);
        const leftWing = new THREE.Mesh(wingGeo, matEnemyWing);
        leftWing.position.x = -20;
        const rightWing = new THREE.Mesh(wingGeo, matEnemyWing);
        rightWing.position.x = 20;
        
        const connGeo = new THREE.CylinderGeometry(3, 3, 40, 8);
        connGeo.rotateZ(Math.PI/2);
        const conn = new THREE.Mesh(connGeo, matEnemyBody);

        this.mesh.add(leftWing);
        this.mesh.add(rightWing);
        this.mesh.add(conn);
        scene.add(this.mesh);
    }
    update(dt) {
        this.timer += dt;
        this.fireTimer -= dt;

        // Only fire when closer
        if (this.fireTimer <= 0 && this.y > -500 && this.y < height - 50 && player) {
             const angle = Math.atan2(player.y - this.y, player.x - this.x);
             bullets.push(new Bullet(this.x, this.y, angle, true));
             AudioSynth.hit(); 
             this.fireTimer = rnd(2, 4);
        }
        
        if (this.moveType === 'sine') {
            this.x += Math.sin(this.timer * 2) * 2;
            this.y += this.vy * dt;
        } else {
            if (player) {
                const dx = player.x - this.x;
                this.vx += dx * 0.5 * dt;
                this.vx *= 0.98; 
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
        }
        this.mesh.rotation.y = Math.sin(this.timer * 3) * 0.3;
        this.sync(this.x, this.y);
    }
}

class PowerUp extends Entity3D {
    constructor(x, y) {
        super();
        this.x = x; this.y = y;
        this.vy = 200; 
        this.radius = 25; 
        const roll = Math.random();
        if (roll < 0.3) this.type = 'HEART';
        else if (roll < 0.55) this.type = 'SHIELD';
        else if (roll < 0.8) this.type = 'CLONE';
        else this.type = 'BEAM';

        let texture;
        if(this.type === 'HEART') texture = texHeart;
        else if(this.type === 'SHIELD') texture = texShield;
        else if(this.type === 'CLONE') texture = texClone;
        else texture = texBeam;

        const mat = new THREE.SpriteMaterial({ 
            map: texture, 
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending 
        });
        
        this.mesh = new THREE.Sprite(mat);
        this.mesh.scale.set(50, 50, 1);
        scene.add(this.mesh);
    }
    update(dt) {
        this.y += this.vy * dt;
        const scale = 50 + Math.sin(Date.now() / 200) * 10;
        this.mesh.scale.set(scale, scale, 1);
        this.sync(this.x, this.y);
    }
}

class Player extends Entity3D {
    constructor() {
        super();
        this.x = width / 2;
        // Start higher up so there is room to move backward
        this.y = height - 250;
        this.radius = 20;
        this.vx = 0;
        this.vy = 0;
        this.color = '#00ffaa';
        this.fireTimer = 0;
        this.hp = 100;
        this.maxHp = 100;
        this.shieldTime = 0;
        this.cloneTime = 0;
        this.beamTime = 0;

        // 3D Ship Mesh
        const geoBody = new THREE.ConeGeometry(12, 45, 8);
        geoBody.rotateX(-Math.PI/2); 
        geoBody.rotateZ(Math.PI/4); 
        const body = new THREE.Mesh(geoBody, matPlayer);
        
        const geoWing = new THREE.BoxGeometry(35, 10, 2);
        const wing = new THREE.Mesh(geoWing, matPlayer);
        wing.position.z = -5;
        
        const engGeo = new THREE.CylinderGeometry(3, 6, 6, 8);
        engGeo.rotateX(Math.PI/2);
        engGeo.translate(0, -25, -2);
        // Ultra Bright Engine
        const engMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 5.0 });
        const engine = new THREE.Mesh(engGeo, engMat);

        this.mesh.add(body);
        this.mesh.add(wing);
        this.mesh.add(engine);
        scene.add(this.mesh);

        const shieldGeo = new THREE.SphereGeometry(40, 32, 32);
        const shieldMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1.0, transparent: true, opacity: 0.3, wireframe: false, side: THREE.DoubleSide });
        this.shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
        this.mesh.add(this.shieldMesh);
        this.shieldMesh.visible = false;

        this.clones = new THREE.Group();
        this.mesh.add(this.clones);
    }
    update(dt) {
        if(this.shieldTime > 0) this.shieldTime -= dt;
        if(this.cloneTime > 0) this.cloneTime -= dt;
        if(this.beamTime > 0) {
             this.beamTime -= dt;
             if(Math.random() < 0.1) AudioSynth.beam();
        }

        if (Math.random() < 0.4) {
            const p = new Particle(this.x + rnd(-5, 5), this.y + 25, '#00ffff', 50, rnd(0.3, 0.6));
            p.vx = -this.vx * 0.2 + rnd(-10, 10);
            p.vy = rnd(100, 200); 
            particles.push(p);
        }

        let dx = 0;
        let dy = 0;
        
        // MOVEMENT: Case-insensitive check handled by Event Listeners now
        if (keys['arrowup'] || keys['w']) dy = -1;
        if (keys['arrowdown'] || keys['s']) dy = 1;
        if (keys['arrowleft'] || keys['a']) dx = -1;
        if (keys['arrowright'] || keys['d']) dx = 1;

        if (mouse.down && mouse.touch) {
            const mx = mouse.x;
            const my = mouse.y;
            dx = (mx - this.x) / 50; 
            dy = (my - this.y) / 50; 
            if(dx > 1) dx = 1; if(dx < -1) dx = -1;
            if(dy > 1) dy = 1; if(dy < -1) dy = -1;
        }

        this.vx += dx * CONFIG.playerSpeed * 5 * dt;
        this.vy += dy * CONFIG.playerSpeed * 5 * dt;
        
        this.vx *= 0.92;
        this.vy *= 0.92;
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Boundaries
        if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.5; }
        if (this.x > width - this.radius) { this.x = width - this.radius; this.vx *= -0.5; }
        
        // Y Boundaries - PREVENTS SHIP FROM GOING OFF SCREEN
        // Top limit (0.4 of screen)
        if (this.y < height * 0.4) { this.y = height * 0.4; this.vy *= -0.5; } 
        // Bottom limit (keeps ship fully visible)
        if (this.y > height - 150) { this.y = height - 150; this.vy *= -0.5; }

        this.fireTimer -= dt;
        if ((keys[' '] || mouse.down) && this.fireTimer <= 0) {
            this.fire();
            this.fireTimer = CONFIG.fireRate;
        }

        this.sync(this.x, this.y);
        this.mesh.rotation.z = -this.vx * 0.002; 
        this.mesh.rotation.x = this.vy * 0.001;
        
        this.shieldMesh.visible = (this.shieldTime > 0);
        if(this.shieldMesh.visible) {
            this.shieldMesh.rotation.y += dt * 2;
            this.shieldMesh.material.opacity = 0.3 + Math.sin(Date.now()/100) * 0.1;
        }

        if (this.cloneTime > 0 && this.clones.children.length === 0) {
            const c1 = this.mesh.children[0].clone();
            const c2 = this.mesh.children[0].clone();
            c1.scale.set(0.6, 0.6, 0.6);
            c2.scale.set(0.6, 0.6, 0.6);
            c1.position.set(-40, 0, 0);
            c2.position.set(40, 0, 0);
            this.clones.add(c1);
            this.clones.add(c2);
        } else if (this.cloneTime <= 0 && this.clones.children.length > 0) {
            this.clones.clear();
        }
        
        // BEAM VISUAL
        if (this.beamTime > 0) {
            if(!this.beamMesh) {
                // MASSIVE Beam
                const bg = new THREE.CylinderGeometry(15, 15, 5000, 16);
                bg.translate(0, 2500, 0);
                
                // Super Bright Material
                const bm = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 });
                this.beamMesh = new THREE.Mesh(bg, bm);
                this.mesh.add(this.beamMesh);
            }
            this.beamMesh.material.opacity = 0.8 + Math.sin(Date.now()/50)*0.2;
            // Pulse width
            const s = 1 + Math.sin(Date.now()/20) * 0.1;
            this.beamMesh.scale.set(s, 1, s);
        } else {
            if(this.beamMesh) {
                this.mesh.remove(this.beamMesh);
                this.beamMesh = null;
            }
        }
    }
    
    fire() {
        if (this.beamTime > 0) return;
        bullets.push(new Bullet(this.x, this.y - 20, -Math.PI/2, false));
        bullets.push(new Bullet(this.x - 15, this.y - 10, -Math.PI/2 - 0.1, false));
        bullets.push(new Bullet(this.x + 15, this.y - 10, -Math.PI/2 + 0.1, false));
        if (this.cloneTime > 0) {
             bullets.push(new Bullet(this.x - 40, this.y, -Math.PI/2, false));
             bullets.push(new Bullet(this.x + 40, this.y, -Math.PI/2, false));
        }
        AudioSynth.laser();
    }
}

// Spawning & Logic
let asteroidTimer = 0;
let enemyTimer = 0;

function spawnEntities(dt) {
    asteroidTimer -= dt;
    if (asteroidTimer <= 0) {
        asteroids.push(new Asteroid());
        asteroidTimer = CONFIG.asteroidSpawnRate / (1 + score/1000); 
    }

    enemyTimer -= dt;
    if (enemyTimer <= 0) {
        enemies.push(new Enemy());
        enemyTimer = CONFIG.enemySpawnRate / (1 + score/2000);
    }
}

function createExplosion(x, y, color, count = 30) {
    AudioSynth.explosion();
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, 300, rnd(0.5, 1.5)));
    }
    screenShake = 15;
}

function checkCollisions() {
    // 1. Powerups
    if (player) {
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            if (dist(player.x, player.y, p.x, p.y) < player.radius + p.radius) {
                AudioSynth.powerup();
                if (p.type === 'HEART') {
                    player.hp = Math.min(player.maxHp, player.hp + 25);
                    uiHealth.style.backgroundColor = '#00ff00'; 
                    setTimeout(() => uiHealth.style.backgroundColor = '#ff0055', 200);
                } else if (p.type === 'SHIELD') player.shieldTime = 10;
                else if (p.type === 'CLONE') player.cloneTime = 15;
                else if (p.type === 'BEAM') player.beamTime = 8;
                p.destroy();
                powerups.splice(i, 1);
            }
        }
    }

    // 2. Beam
    if (player && player.beamTime > 0) {
        const beamW = 120; // WIDER collision for Crush power
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if (Math.abs(e.x - player.x) < beamW && e.y < player.y) {
                createExplosion(e.x, e.y, e.color, 40);
                e.destroy(); enemies.splice(i, 1);
                score += 100;
            }
        }
        for (let i = asteroids.length - 1; i >= 0; i--) {
            const a = asteroids[i];
            if (Math.abs(a.x - player.x) < beamW && a.y < player.y) {
                createExplosion(a.x, a.y, '#aaa', 30);
                a.destroy(); asteroids.splice(i, 1);
                score += 50;
            }
        }
        for (let i = bullets.length - 1; i >= 0; i--) {
             if (bullets[i].isEnemy && Math.abs(bullets[i].x - player.x) < beamW && bullets[i].y < player.y) {
                 bullets[i].destroy(); bullets.splice(i, 1);
             }
        }
    }

    // 3. Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (b.isEnemy) {
            if (player) {
                if (player.shieldTime > 0) {
                     if (dist(b.x, b.y, player.x, player.y) < player.radius + 25) {
                         b.destroy(); bullets.splice(i, 1); AudioSynth.hit();
                     }
                     continue;
                }
                if (dist(b.x, b.y, player.x, player.y) < player.radius + 10) {
                    player.hp -= 10;
                    createExplosion(b.x, b.y, '#ff5500', 15);
                    AudioSynth.hit();
                    b.destroy(); bullets.splice(i, 1);
                    screenShake = 8;
                }
            }
            continue;
        }

        // Hit Enemy?
        for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (dist(b.x, b.y, e.x, e.y) < e.radius + 15) {
                e.hp--;
                createExplosion(b.x, b.y, '#fff', 10);
                AudioSynth.hit();
                b.destroy(); bullets.splice(i, 1);
                
                if (e.hp <= 0) {
                    createExplosion(e.x, e.y, e.color, 40);
                    if (Math.random() < 0.25) powerups.push(new PowerUp(e.x, e.y));
                    e.destroy(); enemies.splice(j, 1);
                    score += 100;
                }
                break;
            }
        }
        if (bullets[i] === undefined) continue;

        // Hit Asteroid?
        for (let k = asteroids.length - 1; k >= 0; k--) {
            const a = asteroids[k];
            if (dist(b.x, b.y, a.x, a.y) < a.radius + 10) {
                a.hp--;
                createExplosion(b.x, b.y, '#aaa', 10);
                AudioSynth.hit();
                b.destroy(); bullets.splice(i, 1);
                
                if (a.hp <= 0) {
                    createExplosion(a.x, a.y, '#aaa', 30);
                    a.destroy(); asteroids.splice(k, 1);
                    score += 50;
                }
                break;
            }
        }
    }

    // 4. Crashes
    if (!player) return;
    for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (dist(player.x, player.y, e.x, e.y) < player.radius + e.radius) {
            if (player.shieldTime <= 0) { player.hp -= 20; screenShake = 25; }
            createExplosion(e.x, e.y, e.color, 50);
            e.destroy(); enemies.splice(j, 1);
        }
    }
    for (let k = asteroids.length - 1; k >= 0; k--) {
        const a = asteroids[k];
        if (dist(player.x, player.y, a.x, a.y) < player.radius + a.radius) {
            if (player.shieldTime <= 0) { player.hp -= 30; screenShake = 25; }
            createExplosion(a.x, a.y, '#aaa', 40);
            a.destroy(); asteroids.splice(k, 1);
        }
    }
}

function clearGame() {
    if(player) { player.destroy(); player = null; }
    bullets.forEach(b => b.destroy()); bullets = [];
    enemies.forEach(e => e.destroy()); enemies = [];
    asteroids.forEach(a => a.destroy()); asteroids = [];
    powerups.forEach(p => p.destroy()); powerups = [];
    particles.forEach(p => p.destroy()); particles = [];
}

function resetGame() {
    clearGame();
    score = 0;
    player = new Player();
    
    CONFIG.asteroidSpawnRate = 1.5;
    CONFIG.enemySpawnRate = 2.5;

    gameOverScreen.classList.add('hidden');
    gameRunning = true;
    lastTime = performance.now();
    requestAnimationFrame(loop);
}

function gameOver() {
    gameRunning = false;
    finalScore.textContent = Math.floor(score);
    gameOverScreen.classList.remove('hidden');
}

function loop(timestamp) {
    if (!gameRunning) {
        if(composer) composer.render();
        return;
    }

    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;

    updateStarfield(dt);
    spawnEntities(dt);
    if(player) player.update(dt);

    powerups = powerups.filter(p => {
        p.update(dt);
        if(p.y > height + 50) { p.destroy(); return false; }
        return true;
    });

    bullets = bullets.filter(b => {
        b.update(dt);
        if(b.life <= 0) { b.destroy(); return false; }
        return true;
    });

    enemies = enemies.filter(e => {
        e.update(dt);
        if(e.y > height + 100) { e.destroy(); return false; }
        return true;
    });

    asteroids = asteroids.filter(a => {
        a.update(dt);
        if(a.y > height + 100) { a.destroy(); return false; }
        return true;
    });

    particles = particles.filter(p => {
        p.update(dt);
        if(p.life <= 0) { p.destroy(); return false; }
        return true;
    });

    checkCollisions();

    uiScore.textContent = Math.floor(score);
    if (player) {
        const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
        uiHealth.style.width = hpPercent + '%';

        const targetCamX = player.mesh.position.x * 0.3; 
        camera.position.x += (targetCamX - camera.position.x) * 0.1;
        
        if (screenShake > 0) {
            camera.position.x += rnd(-screenShake, screenShake);
            camera.position.y += rnd(-screenShake, screenShake);
            screenShake *= 0.9;
            if(screenShake < 0.5) screenShake = 0;
        }

        if (player.hp <= 0) {
            createExplosion(player.x, player.y, player.color, 60);
            player.destroy();
            player = null;
            setTimeout(gameOver, 1000); 
        }
    }

    // Use composer for post-processing render
    if(composer) composer.render();
    requestAnimationFrame(loop);
}

// Input Handlers - UPDATED TO FIX "S" KEY ISSUE
// Converting to lowercase ensures Caps Lock doesn't break controls
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

const updateInputCoords = (e) => {
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
        mouse.touch = true;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
        mouse.touch = false;
    }
    mouse.x = clientX;
    mouse.y = clientY;
};

window.addEventListener('mousedown', e => { mouse.down = true; updateInputCoords(e); });
window.addEventListener('mouseup', () => mouse.down = false);
window.addEventListener('mousemove', updateInputCoords);
window.addEventListener('touchstart', e => { mouse.down = true; updateInputCoords(e); }, {passive: false});
window.addEventListener('touchend', () => mouse.down = false);
window.addEventListener('touchmove', e => { updateInputCoords(e); e.preventDefault(); }, {passive: false});

document.getElementById('start-btn').addEventListener('click', () => {
    AudioSynth.init(); 
    initThree();
    startScreen.classList.add('hidden');
    resetGame();
});

document.getElementById('restart-btn').addEventListener('click', () => {
    resetGame();
});

</script>
</body>
</html>
